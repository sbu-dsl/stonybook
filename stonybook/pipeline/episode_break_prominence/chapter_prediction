class DPSolver():
    def __init__(self, peaks, prominences, num_paras, breaks_to_insert, alpha):
        self.peaks = list(peaks)
        self.peaks.append(num_paras)
        self.prominences = prominences
        self.prominences.append(0)
        self.num_sentences = num_paras
        self.k = breaks_to_insert
        self.dp_dict = dict()
        self.N = len(self.peaks) - 1
        self.ideal_length = num_paras / (self.k + 1)
        self.prev_dict = dict()
        self.alpha = alpha
    
    def get_distance(self, idx1, idx2):
        if idx1 == -1:
            return self.peaks[idx2] / self.ideal_length
        sent_1 = self.peaks[idx1]
        sent_2 = self.peaks[idx2]
        return (abs((sent_2 - sent_1) - self.ideal_length)) / self.ideal_length
    
    def get_mins(self, costs):
        keys = list(costs.keys())
        min_key = keys[0]
        min_val = costs[keys[0]]
        for k in keys[1:]:
            if costs[k] < min_val:
                min_val = costs[k]
                min_key = k
        return min_key, min_val
    
    def dp_func(self, N, k):
        if k > N:
            return None
        # Memoized
        if (N, k) in self.dp_dict:
            return self.dp_dict[(N, k)]
        # Base case
        if k == 0:
            self.dp_dict[(N, k)] = -(self.prominences[N] * self.alpha) + (self.get_distance(-1, N) * (1 - self.alpha))
            return self.dp_dict[(N, k)]
        
        # Recursive call
        costs = dict()
        for i in range(0, N):
            c = self.dp_func(i, k - 1)
            if c:
                costs[i] = c + (self.get_distance(i, N) * (1 - self.alpha))
        if len(costs) == 0:
            self.dp_dict[(N, k)] = None
            return None
        
        min_N, min_cost = self.get_mins(costs)
        
        ans = min_cost - (self.prominences[N] * self.alpha)
        self.dp_dict[(N, k)] = ans
        self.prev_dict[(N, k)] = min_N
        return ans
    
    def solve(self):
        x = self.dp_func(self.N, self.k)
        return x
    
    def get_best_sequence(self):
        x = self.solve()
        ans_seq = list()
        N = self.N
        k = self.k
        while True:
            if (N, k) not in self.prev_dict:
                break
            previous = self.prev_dict[(N, k)]
            ans_seq.append(previous)
            N = previous
            k -= 1
        return ans_seq[::-1]

def get_preds(data, num_preds = -1, alpha = 0.8):
    densities = data["densities"]
    peaks = data["peaks"]
    prominences = data["prominences"]

    if len(densities) < 2:
        return []

    max_num = max(densities.keys())

    #considering average chapter size to be 4000 works
    if num_preds == -1:
        num_preds = int(data["num_tokens"] / 4000)    

    dps = DPSolver(peaks, prominences, max_num + 1, num_preds, alpha)
    preds = dps.get_best_sequence()
    dp_predictions = [peaks[x] for x in preds]
    return dp_predictions